# Receipt Analysis System — запуск и использование

## Что это

Сервис для загрузки чеков (картинки), автоматического извлечения данных (OCR + структурирование), нормализации сумм в **USD**, а также чат-интерфейс “вопрос -> SQL -> ответ”.

В комплекте:

* **Web UI**: `http://localhost:8000/`
* **Swagger**: `http://localhost:8000/docs`
* **API + worker** поднимаются через Docker Compose.

---

## Требования

* **Docker Desktop** (с docker compose)
* **OpenAI API key** (используется `gpt-4o-mini`)

Опционально (для локальных тестовых скриптов):

* Python 3.11+ (если хотите запускать `bulk_upload_receipts.py` на хосте)

---

## Быстрый старт

### 1) Склонировать репозиторий

```bash
git clone <your-repo-url>
cd receipt_analysis_system
```

### 2) Создать `.env`

Скопируйте пример и заполните значения:

```bash
cp .env.example .env
```

На Windows можно просто создать файл `.env` рядом с `docker-compose.yml`.

Минимум, который нужно заполнить:

* `OPENAI_API_KEY=...`
* `JWT_SECRET_KEY=...` (любой длинный случайный секрет)

По желанию актуализировать курс доллара к доступным валютам:
* `FX_EUR_TO_USD=...`
* `FX_CHF_TO_USD=...`
* `FX_RUB_TO_USD=...`

### 3) Запустить

```bash
docker compose up --build
```

Открыть:

* Web: `http://localhost:8000/`
* Docs: `http://localhost:8000/docs`

---

## Переменные окружения (.env)

Обязательные:

* `OPENAI_API_KEY`
* `JWT_SECRET_KEY`

* `DATABASE_URL=sqlite:////app/app/data/app.db`
* FX (курсы):

  * `FX_EUR_TO_USD` (сколько USD за 1 EUR)
  * `FX_CHF_TO_USD` (сколько USD за 1 CHF)
  * `FX_USD_TO_RUB` (сколько RUB за 1 USD)

Модели (если хотите явно):

* `OPENAI_OCR_MODEL` (по умолчанию `gpt-4o-mini`)
* `OPENAI_STRUCT_MODEL`
* `OPENAI_SQL_MODEL`
* `OPENAI_SUMMARY_MODEL`

Worker тюнинг (обычно не нужно трогать):

* `WORKER_POLL_SECONDS`
* `TASK_MAX_ATTEMPTS`
* `TASK_LOCK_TIMEOUT_SECONDS`

---

## Как пользоваться через Web UI

### 1) Регистрация / логин

На главной странице:

1. Register (если пользователь ещё не создан)
2. Login

Токен хранится в `localStorage`.

### 2) Загрузка чеков

1. Выберите изображение (jpg/png/…)
2. Выберите **Currency**:

   * `AUTO` — рекомендовано: валюта пытается определиться моделью при разборе
   * или вручную: `USD/EUR/CHF/RUB`
3. Нажмите **Upload**

Чек создаётся со статусом `queued` и уходит на асинхронную обработку worker’ом.

### 3) Статусы и детали

* `queued` -> `processing` -> `done` / `error`
* Нажмите **Open** чтобы увидеть детали: merchant, date, total, items, raw_ocr_text/raw_llm_json и т.д.
* Кнопка **Poll** обновляет статус.

### 4) Валюта, USD-нормализация и ручная корректировка

* В БД хранятся:

  * исходная валюта чека (`currency`)
  * распознанная моделью (`detected_currency`, может быть `null`)
  * нормализованные суммы: `total_usd`, `line_total_usd`
* Если чек обработан неверно по валюте:

  1. Откройте чек (**Open**)
  2. Переключите Currency в нужную
  3. Нажмите **Reprocess**

`Reprocess` создаёт новую задачу и пересчитывает USD-суммы.

### 5) Категории расходов

Для каждого чека определяется **одна категория** из фиксированного набора (пример):
`GROCERIES, CAFE, RESTAURANT, TRANSPORT, PHARMACY, UTILITIES, ENTERTAINMENT, CLOTHING, ELECTRONICS, OTHER`

Это используется в чате (см. ниже).

### 6) Чат

Вводите вопрос в блоке **Chat**. Примеры:

* «Сколько я потратил вчера?»
* «Сколько я потратил в кафе?»
* «Top merchants last month»
* «Сколько я потратил в рублях?»

Важно:

* SQL всегда считается по **USD-полям**, а если вы просите «в рублях/евро/франках», итоговый текст переводит **summarizer** (без дополнительных функций), используя FX из `.env`.
* Есть **rate limit** на `/chat` (ограничение запросов/мин на пользователя).

---

## Ограничения (важные)

* **SQLite**: подходит для демо/MVP, но ограничивает параллельную запись. По умолчанию рекомендован **1 worker**.
* Обработка чеков зависит от качества OCR/LLM:

  * Items ограничены (например, до 50) чтобы избегать огромных JSON.
  * Для очень длинных чеков возможен fallback: поля чека сохранятся, но items могут быть пустыми.
* FX — статические из env (не подтягиваются автоматически из внешних источников).
* Чат “статлесс”: каждый запрос независим (без истории диалога).
* SQL sandbox:

  * Только `SELECT`, один statement
  * Принудительный `WHERE user_id = :uid`
  * Принудительный `LIMIT 200`

---

## Как прогнать тесты/смоук тест

### Вариант A: через Web UI

1. Register/Login
2. Upload 1–2 чека
3. Дождаться `done`
4. Задать вопрос в Chat

### Вариант B: bulk загрузка из папки (для тестов)

Есть скрипт **`bulk_upload_receipts.py`**: загружает много картинок в аккаунт как будто через веб (multipart form) и ставит валюту `AUTO`.

#### Запуск с хоста (рекомендуется)

Убедитесь, что контейнеры подняты:

```bash
docker compose up -d
```

Потом:

```bash
python bulk_upload_receipts.py --base-url http://127.0.0.1:8000 ^
  --folder "C:\path\to\receipts" ^
  --username test_user_1 --password secret123 ^
  --currency AUTO --wait
```

Полезные опции:

* `--sleep 0.5` (если нужно снизить нагрузку на OpenAI)
* `--limit 20` (загрузить только N файлов)
* без `--wait` — просто закинуть в очередь

---

## Troubleshooting

### “processing завис надолго”

* Обычно это OpenAI/сеть/лимиты.
* Можно нажать **Reprocess**.
* Смотрите `receipt.error` в деталях чека.

### “Нужно сбросить всё и начать с нуля”

Данные лежат в docker volumes (sqlite + uploads). Полный сброс:

```bash
docker compose down -v
docker compose up --build
```

---

## Где лежат данные

В Docker это volumes:

* `app_data` — SQLite DB
* `app_uploads` — загруженные изображения

Поэтому перезапуск контейнеров данные не удаляет (удаляются только `down -v`).



## Пояснительная записка к MVP

# 1) Цели MVP и границы задачи

### Цели

* Быстро получить **end-to-end вертикальный срез**:

  1. загрузка чеков (изображения),
  2. асинхронная обработка (OCR -> JSON),
  3. хранение структурированных данных,
  4. чат: NL -> SQL -> ответ,
  5. изоляция данных пользователей.

### Не цели (осознанно отложено)

* Продакшен-очередь/брокер задач, горизонтальный масштаб воркеров.
* Внешние провайдеры курсов валют, бухгалтерские нюансы.
* Сложный фронтенд/UX и полноценная “история диалогов”.
* Глубокая аналитика на уровне BI/дашбордов.
* Переезд на postgres.
* Перевод всей логики во внутренний контур за счет локальных моделей.
* Логгирование процесса.
* Создание шаблонов вопросов с готовыми шаблонами sql запросов. Если вопрос пользователя достаточно похож на шаблонный (по bm25 или cosine), то из него парсятся данные и подставляются в готовый sql запрос.
* Поддержка истории диалога.
* Создание системы тестов.

---

# 2) Архитектура сервиса

### Компоненты

* **API (FastAPI)**: регистрация/логин, upload чеков, просмотр чеков, reprocess, чат.
* **Worker**: асинхронно обрабатывает чеки из очереди в БД (SQLite).
* **SQLite**: единый файл БД.
* **Web UI**: простой HTML/JS без отдельного фронтенд-стека.
* **OpenAI (gpt-4o-mini)**: используется для vision OCR и для структурирования в JSON, плюс для чат-summarizer и генерации SQL.

### Поток “Upload -> Processing”

1. Пользователь загружает изображение -> создаётся `Receipt` со статусом `queued`.
2. Создаётся `ReceiptTask` (очередь в БД).
3. Worker забирает задачу, делает:
   * OCR (vision),
   * структурирование (JSON),
   * нормализация сумм в USD,
   * классификация категории,
   * сохранение в БД,
   * перевод статуса `done`/`error`.

### Поток “Chat”

1. Вопрос пользователя -> **intent router**:
   * сначала canned intents (быстрые шаблоны),
   * затем fallback: LLM генерирует SQL.

2. SQL прогоняется через **SQL sandbox**:
   * только `SELECT`,
   * один statement,
   * запрет опасных сущностей,
   * принудительный `WHERE receipts.user_id = :uid`,
   * `LIMIT 200`.

3. Выполнение запроса -> табличный результат.

4. **Answer summarizer**: LLM получает вопрос + табличку и возвращает финальный ответ.

---

# 3) Обоснование выбора стека

### FastAPI

* Дефолтный выбор.

### SQLite

* Минимум инфраструктуры: один файл -> легко запустить “у любого” через docker volumes.
* Достаточно для задачи с 1 воркером и небольшим объёмом данных.

### Встроенная очередь в БД (ReceiptTask)

* Это проще и надёжнее, чем поднимать Redis/Celery.
* Уже есть следующие элементы:

  * lock (processing/locked_by),
  * попытки/attempts,
  * requeue stuck tasks.

### OpenAI gpt-4o-mini

* Даёт хороший баланс цена/качество.
* Закрывает сразу несколько задач: OCR, JSON extraction, NL->SQL, summary.

---

# 4) Ключевые решения

## 4.1 Асинхронность обработки

* Upload не блокирует пользователя: `queued -> processing -> done`.
* Есть `POST /receipts/{id}/reprocess`:

  * создаёт новую задачу,
  * сбрасывает поля результата и статус,
  * позволяет переобработать после изменения промпта/логики.

## 4.2 Устойчивость структурирования

* Items ограничены (до 50), чтобы избегать обрезания JSON.
* Есть fallback режим: если модель не вернула валидный JSON (или слишком длинный чек) — сохраняем хотя бы ключевые поля (merchant/date/total/currency) и `items=[]`, вместо падения всего чека.

## 4.3 Безопасность выполнения SQL

* Встроен SQL sandbox (sqlglot + ручные проверки).
* Жёстко enforced multi-tenancy:

  * даже если LLM “забыл”, код принудительно добавляет `WHERE user_id = :uid`.
* Запрет опасных сущностей и операций, только `SELECT`, `LIMIT 200`.

## 4.4 Логи запросов и rate limiting

* Таблица `chat_queries`: фиксируем `question`, `chosen_source`, `generated_sql`, `sandbox_sql`, `error`, `latency_ms`.
* Примитивный rate limit на `/chat` per-user, чтобы случайно не “положить” лимиты OpenAI.

## 4.5 Кэш canned intents

* Частые шаблонные вопросы кэшируются и обслуживаются быстрее и дешевле:

  * меньше вызовов OpenAI,
  * меньше нагрузки на БД.

---

# 5) Валюты и нормализация

### Проблема

Чеки могут быть в разных валютах, но аналитика должна быть консистентной.

### Решение в MVP

* При загрузке пользователь выбирает `currency` (по умолчанию **AUTO**).
* Во время обработки модель пытается определить `detected_currency`.
* Итоговая `receipt.currency`:

  * если пользователь указал явно (USD/EUR/CHF/RUB) — доверяем пользователю,
  * если `AUTO` — ставим `detected_currency`, иначе fallback USD.
* Всегда считаются:

  * `total_usd`,
  * `line_total_usd`,
    используя FX из `.env`.

### Почему перевод “в рублях” делается в summarizer

* SQL всегда возвращает USD -> проще, безопаснее, единообразно.
* Summarizer в ответе переводит USD в requested currency (RUB/EUR/CHF) по FX из env — без дополнительных функций/эндпоинтов.

---

# 6) Категории расходов

### Зачем

Запросы типа “сколько я потратил в кафе?” проще и стабильнее, когда есть готовая категория.

### Реализация

* В `Receipt` хранится `category` из небольшого фиксированного списка (`CAFE`, `GROCERIES`, …, `OTHER`).
* Категория определяется в процессе structuring (в том же JSON-ответе модели).
* В чат-подсказках модель знает, что нужно фильтровать по `receipts.category`.

---

# 7) Известные ограничения MVP

* SQLite + 1 worker: ограничение на конкурентные записи.
* Качество OCR/структурирования зависит от качества картинки и содержимого.
* FX статические (env), без автоматического обновления.
* Чат без контекста истории: каждый запрос независимый.
* Простая модель категорий (одна категория на чек).

---

# 8) Следующие шаги

## 8.1 “Усиление” без смены архитектуры

* Prompt versioning: хранить `prompt_version` в ReceiptTask/Receipt для воспроизводимости.
* Автотесты:

  * unit тесты sandbox (обязательные),
  * интеграционные тесты API (upload/chat).
* Улучшить canned intents.
* Больше эвристик до LLM (например, по валюте/категории по ключевым словам) для снижения стоимости.

## 8.2 Масштабирование и продакшенизация

* **PostgreSQL** вместо SQLite.
* Очередь задач:

  * Redis + RQ/Celery или полноценный брокер (RabbitMQ/Kafka по необходимости).
* Хранилище изображений:

  * S3/MinIO вместо локальной папки.
* Горизонтальный масштаб:

  * несколько воркеров,
  * несколько API реплик за балансировщиком.
* Observability:

  * structured logs,
  * метрики (Prometheus),
  * трассировка (OpenTelemetry).

## 8.3 Умнее аналитика

* Векторные эмбеддинги по merchant/items для более мягкого intent matching.
* Персистентная история диалога + “conversation state”.
* Нормализация merchant (каноникализация, fuzzy matching).
